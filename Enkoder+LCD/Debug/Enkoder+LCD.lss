
Enkoder+LCD.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000006e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000006e6  0000077a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000007  00800060  00800060  0000077a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000077a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000e8  00000000  00000000  000007aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000012fe  00000000  00000000  00000892  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000656  00000000  00000000  00001b90  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000064a  00000000  00000000  000021e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000218  00000000  00000000  00002830  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000034a  00000000  00000000  00002a48  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000b3b  00000000  00000000  00002d92  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000148  00000000  00000000  000038cd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	2b c0       	rjmp	.+86     	; 0x58 <__ctors_end>
   2:	3a c0       	rjmp	.+116    	; 0x78 <__bad_interrupt>
   4:	39 c0       	rjmp	.+114    	; 0x78 <__bad_interrupt>
   6:	38 c0       	rjmp	.+112    	; 0x78 <__bad_interrupt>
   8:	37 c0       	rjmp	.+110    	; 0x78 <__bad_interrupt>
   a:	36 c0       	rjmp	.+108    	; 0x78 <__bad_interrupt>
   c:	35 c0       	rjmp	.+106    	; 0x78 <__bad_interrupt>
   e:	34 c0       	rjmp	.+104    	; 0x78 <__bad_interrupt>
  10:	33 c0       	rjmp	.+102    	; 0x78 <__bad_interrupt>
  12:	32 c0       	rjmp	.+100    	; 0x78 <__bad_interrupt>
  14:	31 c0       	rjmp	.+98     	; 0x78 <__bad_interrupt>
  16:	30 c0       	rjmp	.+96     	; 0x78 <__bad_interrupt>
  18:	2f c0       	rjmp	.+94     	; 0x78 <__bad_interrupt>
  1a:	2e c0       	rjmp	.+92     	; 0x78 <__bad_interrupt>
  1c:	2d c0       	rjmp	.+90     	; 0x78 <__bad_interrupt>
  1e:	2c c0       	rjmp	.+88     	; 0x78 <__bad_interrupt>
  20:	2b c0       	rjmp	.+86     	; 0x78 <__bad_interrupt>
  22:	2a c0       	rjmp	.+84     	; 0x78 <__bad_interrupt>
  24:	29 c0       	rjmp	.+82     	; 0x78 <__bad_interrupt>

00000026 <__trampolines_end>:
  26:	34 32       	cpi	r19, 0x24	; 36
  28:	30 20       	and	r3, r0
  2a:	42 4c       	sbci	r20, 0xC2	; 194
  2c:	41 5a       	subi	r20, 0xA1	; 161
  2e:	45 20       	and	r4, r5
  30:	49 54       	subi	r20, 0x49	; 73
	...

00000033 <__c.1968>:
  33:	47 49 54 20 47 55 44 20 46 41 47 47 45 54 00        GIT GUD FAGGET.

00000042 <__c.1963>:
  42:	4a 55 4d 50 00                                      JUMP.

00000047 <__c.1961>:
  47:	41 00                                               A.

00000049 <__c.1959>:
  49:	48 5a 00                                            HZ.

0000004c <__c.1957>:
  4c:	41 4d 50 3a 00                                      AMP:.

00000051 <__c.1955>:
  51:	46 52 45 51 3a 00 00                                FREQ:..

00000058 <__ctors_end>:
  58:	11 24       	eor	r1, r1
  5a:	1f be       	out	0x3f, r1	; 63
  5c:	cf e5       	ldi	r28, 0x5F	; 95
  5e:	d4 e0       	ldi	r29, 0x04	; 4
  60:	de bf       	out	0x3e, r29	; 62
  62:	cd bf       	out	0x3d, r28	; 61

00000064 <__do_clear_bss>:
  64:	20 e0       	ldi	r18, 0x00	; 0
  66:	a0 e6       	ldi	r26, 0x60	; 96
  68:	b0 e0       	ldi	r27, 0x00	; 0
  6a:	01 c0       	rjmp	.+2      	; 0x6e <.do_clear_bss_start>

0000006c <.do_clear_bss_loop>:
  6c:	1d 92       	st	X+, r1

0000006e <.do_clear_bss_start>:
  6e:	a7 36       	cpi	r26, 0x67	; 103
  70:	b2 07       	cpc	r27, r18
  72:	e1 f7       	brne	.-8      	; 0x6c <.do_clear_bss_loop>
  74:	ff d0       	rcall	.+510    	; 0x274 <main>
  76:	35 c3       	rjmp	.+1642   	; 0x6e2 <_exit>

00000078 <__bad_interrupt>:
  78:	c3 cf       	rjmp	.-122    	; 0x0 <__vectors>

0000007a <lcd_init>:
#include <util\delay.h>

void lcd_init()
{

	hd44780_init();				//Podstawowa inicjalizacja modu³u
  7a:	bb d2       	rcall	.+1398   	; 0x5f2 <hd44780_init>
	hd44780_outcmd(HD44780_CLR);	//Wyczyœæ pamiêæ DDRAM
  7c:	60 e0       	ldi	r22, 0x00	; 0
  7e:	81 e0       	ldi	r24, 0x01	; 1
  80:	98 d2       	rcall	.+1328   	; 0x5b2 <hd44780_outbyte>
	hd44780_wait_ready(1000);
  82:	81 e0       	ldi	r24, 0x01	; 1
  84:	b1 d2       	rcall	.+1378   	; 0x5e8 <hd44780_wait_ready>
	hd44780_outcmd(HD44780_ENTMODE(1, 0));	//Tryb autoinkrementacji AC
  86:	60 e0       	ldi	r22, 0x00	; 0
  88:	86 e0       	ldi	r24, 0x06	; 6
  8a:	93 d2       	rcall	.+1318   	; 0x5b2 <hd44780_outbyte>
	hd44780_wait_ready(1000);
  8c:	81 e0       	ldi	r24, 0x01	; 1
  8e:	ac d2       	rcall	.+1368   	; 0x5e8 <hd44780_wait_ready>
	hd44780_outcmd(HD44780_DISPCTL(1, 0, 0));	//W³¹cz wyœwietlacz, wy³¹cz kursor
  90:	60 e0       	ldi	r22, 0x00	; 0
  92:	8c e0       	ldi	r24, 0x0C	; 12
  94:	8e d2       	rcall	.+1308   	; 0x5b2 <hd44780_outbyte>
	hd44780_wait_ready(1000);
  96:	81 e0       	ldi	r24, 0x01	; 1
  98:	a7 d2       	rcall	.+1358   	; 0x5e8 <hd44780_wait_ready>
  9a:	08 95       	ret

0000009c <lcd_putchar>:
}

void lcd_putchar(char c)
{
  9c:	cf 93       	push	r28
  9e:	c8 2f       	mov	r28, r24
	static bool second_nl_seen;
	static uint8_t line=0;
	
	if ((second_nl_seen) && (c != '\n')&&(line==0))
  a0:	80 91 61 00 	lds	r24, 0x0061
  a4:	88 23       	and	r24, r24
  a6:	81 f0       	breq	.+32     	; 0xc8 <lcd_putchar+0x2c>
  a8:	ca 30       	cpi	r28, 0x0A	; 10
  aa:	81 f0       	breq	.+32     	; 0xcc <lcd_putchar+0x30>
  ac:	80 91 60 00 	lds	r24, 0x0060
  b0:	81 11       	cpse	r24, r1
  b2:	1f c0       	rjmp	.+62     	; 0xf2 <lcd_putchar+0x56>
	{//Odebrano pierwszy znak
		hd44780_wait_ready(40);
  b4:	81 e0       	ldi	r24, 0x01	; 1
  b6:	98 d2       	rcall	.+1328   	; 0x5e8 <hd44780_wait_ready>
		hd44780_outcmd(HD44780_CLR);
  b8:	60 e0       	ldi	r22, 0x00	; 0
  ba:	81 e0       	ldi	r24, 0x01	; 1
  bc:	7a d2       	rcall	.+1268   	; 0x5b2 <hd44780_outbyte>
		hd44780_wait_ready(1600);
  be:	81 e0       	ldi	r24, 0x01	; 1
  c0:	93 d2       	rcall	.+1318   	; 0x5e8 <hd44780_wait_ready>
		second_nl_seen=false;
  c2:	10 92 61 00 	sts	0x0061, r1
  c6:	15 c0       	rjmp	.+42     	; 0xf2 <lcd_putchar+0x56>
	}
	if (c == '\n')
  c8:	ca 30       	cpi	r28, 0x0A	; 10
  ca:	99 f4       	brne	.+38     	; 0xf2 <lcd_putchar+0x56>
	{
		if (line==0)
  cc:	80 91 60 00 	lds	r24, 0x0060
  d0:	81 11       	cpse	r24, r1
  d2:	09 c0       	rjmp	.+18     	; 0xe6 <lcd_putchar+0x4a>
		{
			line++;
  d4:	81 e0       	ldi	r24, 0x01	; 1
  d6:	80 93 60 00 	sts	0x0060, r24
			hd44780_outcmd(HD44780_DDADDR(64));	//Adres pierwszego znaku drugiej linii
  da:	60 e0       	ldi	r22, 0x00	; 0
  dc:	80 ec       	ldi	r24, 0xC0	; 192
  de:	69 d2       	rcall	.+1234   	; 0x5b2 <hd44780_outbyte>
			hd44780_wait_ready(1000);
  e0:	81 e0       	ldi	r24, 0x01	; 1
  e2:	82 d2       	rcall	.+1284   	; 0x5e8 <hd44780_wait_ready>
  e4:	0b c0       	rjmp	.+22     	; 0xfc <lcd_putchar+0x60>
		}
		else
		{
			second_nl_seen=true;
  e6:	81 e0       	ldi	r24, 0x01	; 1
  e8:	80 93 61 00 	sts	0x0061, r24
			line=0;
  ec:	10 92 60 00 	sts	0x0060, r1
  f0:	05 c0       	rjmp	.+10     	; 0xfc <lcd_putchar+0x60>
		}
	}
	else
	{
		hd44780_outdata(c);
  f2:	61 e0       	ldi	r22, 0x01	; 1
  f4:	8c 2f       	mov	r24, r28
  f6:	5d d2       	rcall	.+1210   	; 0x5b2 <hd44780_outbyte>
		hd44780_wait_ready(40);
  f8:	81 e0       	ldi	r24, 0x01	; 1
  fa:	76 d2       	rcall	.+1260   	; 0x5e8 <hd44780_wait_ready>
	}
}
  fc:	cf 91       	pop	r28
  fe:	08 95       	ret

00000100 <lcd_puttext>:
		txt++;
	}
}

void lcd_puttext(const char __memx *txt)
{
 100:	cf 92       	push	r12
 102:	df 92       	push	r13
 104:	ef 92       	push	r14
 106:	6b 01       	movw	r12, r22
 108:	e8 2e       	mov	r14, r24
	char ch;
	while((ch=*txt))
 10a:	fb 01       	movw	r30, r22
 10c:	84 91       	lpm	r24, Z
 10e:	e7 fc       	sbrc	r14, 7
 110:	80 81       	ld	r24, Z
 112:	88 23       	and	r24, r24
 114:	59 f0       	breq	.+22     	; 0x12c <lcd_puttext+0x2c>
	{
		lcd_putchar(ch);
 116:	c2 df       	rcall	.-124    	; 0x9c <lcd_putchar>
		txt++;
 118:	8f ef       	ldi	r24, 0xFF	; 255
 11a:	c8 1a       	sub	r12, r24
 11c:	d8 0a       	sbc	r13, r24
 11e:	e8 0a       	sbc	r14, r24
}

void lcd_puttext(const char __memx *txt)
{
	char ch;
	while((ch=*txt))
 120:	f6 01       	movw	r30, r12
 122:	84 91       	lpm	r24, Z
 124:	e7 fc       	sbrc	r14, 7
 126:	80 81       	ld	r24, Z
 128:	81 11       	cpse	r24, r1
 12a:	f5 cf       	rjmp	.-22     	; 0x116 <lcd_puttext+0x16>
	{
		lcd_putchar(ch);
		txt++;
	}
}
 12c:	ef 90       	pop	r14
 12e:	df 90       	pop	r13
 130:	cf 90       	pop	r12
 132:	08 95       	ret

00000134 <lcd_goto>:

void lcd_goto(uint8_t x, uint8_t y)
{
 hd44780_outcmd(HD44780_DDADDR(0x40*y+x));
 134:	90 e4       	ldi	r25, 0x40	; 64
 136:	69 9f       	mul	r22, r25
 138:	80 0d       	add	r24, r0
 13a:	11 24       	eor	r1, r1
 13c:	60 e0       	ldi	r22, 0x00	; 0
 13e:	80 68       	ori	r24, 0x80	; 128
 140:	38 d2       	rcall	.+1136   	; 0x5b2 <hd44780_outbyte>
 hd44780_wait_ready(1000);
 142:	81 e0       	ldi	r24, 0x01	; 1
 144:	51 d2       	rcall	.+1186   	; 0x5e8 <hd44780_wait_ready>
 146:	08 95       	ret

00000148 <lcd_cls>:
}

void lcd_cls()
{
 hd44780_outcmd(HD44780_CLR);
 148:	60 e0       	ldi	r22, 0x00	; 0
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	32 d2       	rcall	.+1124   	; 0x5b2 <hd44780_outbyte>
 hd44780_wait_ready(false);
 14e:	80 e0       	ldi	r24, 0x00	; 0
 150:	4b d2       	rcall	.+1174   	; 0x5e8 <hd44780_wait_ready>
 152:	08 95       	ret

00000154 <refresh>:
#include "enkoder.c"
#include <avr\pgmspace.h>
#include <util\delay.h>
#include <stdlib.h>

void refresh(uint32_t freq, uint32_t amp, uint32_t fjump, uint32_t ajump, bool select){
 154:	4f 92       	push	r4
 156:	5f 92       	push	r5
 158:	6f 92       	push	r6
 15a:	7f 92       	push	r7
 15c:	8f 92       	push	r8
 15e:	af 92       	push	r10
 160:	bf 92       	push	r11
 162:	cf 92       	push	r12
 164:	df 92       	push	r13
 166:	ef 92       	push	r14
 168:	ff 92       	push	r15
 16a:	0f 93       	push	r16
 16c:	1f 93       	push	r17
 16e:	cf 93       	push	r28
 170:	df 93       	push	r29
 172:	cd b7       	in	r28, 0x3d	; 61
 174:	de b7       	in	r29, 0x3e	; 62
 176:	60 97       	sbiw	r28, 0x10	; 16
 178:	0f b6       	in	r0, 0x3f	; 63
 17a:	f8 94       	cli
 17c:	de bf       	out	0x3e, r29	; 62
 17e:	0f be       	out	0x3f, r0	; 63
 180:	cd bf       	out	0x3d, r28	; 61
 182:	2b 01       	movw	r4, r22
 184:	3c 01       	movw	r6, r24
 186:	29 87       	std	Y+9, r18	; 0x09
 188:	3a 87       	std	Y+10, r19	; 0x0a
 18a:	4b 87       	std	Y+11, r20	; 0x0b
 18c:	5c 87       	std	Y+12, r21	; 0x0c
 18e:	ed 86       	std	Y+13, r14	; 0x0d
 190:	fe 86       	std	Y+14, r15	; 0x0e
 192:	0f 87       	std	Y+15, r16	; 0x0f
 194:	18 8b       	std	Y+16, r17	; 0x10
	char str[8];
	lcd_cls();
 196:	d8 df       	rcall	.-80     	; 0x148 <lcd_cls>
	lcd_goto(0,0);
 198:	60 e0       	ldi	r22, 0x00	; 0
 19a:	80 e0       	ldi	r24, 0x00	; 0
 19c:	cb df       	rcall	.-106    	; 0x134 <lcd_goto>
	if(select){
 19e:	88 20       	and	r8, r8
 1a0:	19 f1       	breq	.+70     	; 0x1e8 <refresh+0x94>
		lcd_puttext(PSTR("FREQ:"));
 1a2:	61 e5       	ldi	r22, 0x51	; 81
 1a4:	70 e0       	ldi	r23, 0x00	; 0
 1a6:	80 e0       	ldi	r24, 0x00	; 0
 1a8:	ab df       	rcall	.-170    	; 0x100 <lcd_puttext>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
 1aa:	4a e0       	ldi	r20, 0x0A	; 10
 1ac:	8e 01       	movw	r16, r28
 1ae:	0f 5f       	subi	r16, 0xFF	; 255
 1b0:	1f 4f       	sbci	r17, 0xFF	; 255
 1b2:	b8 01       	movw	r22, r16
 1b4:	c2 01       	movw	r24, r4
 1b6:	62 d2       	rcall	.+1220   	; 0x67c <__itoa_ncheck>
	}
	else{
		lcd_puttext(PSTR("AMP:"));
		itoa(amp, str, 10);
	}
	lcd_goto(5,0);
 1b8:	60 e0       	ldi	r22, 0x00	; 0
 1ba:	85 e0       	ldi	r24, 0x05	; 5
 1bc:	bb df       	rcall	.-138    	; 0x134 <lcd_goto>
	lcd_puttext(str);
 1be:	c8 01       	movw	r24, r16
 1c0:	a0 e8       	ldi	r26, 0x80	; 128
 1c2:	50 2e       	mov	r5, r16
 1c4:	69 2e       	mov	r6, r25
 1c6:	7a 2e       	mov	r7, r26
 1c8:	bc 01       	movw	r22, r24
 1ca:	8a 2f       	mov	r24, r26
 1cc:	99 df       	rcall	.-206    	; 0x100 <lcd_puttext>
	lcd_goto(14,0);
 1ce:	60 e0       	ldi	r22, 0x00	; 0
 1d0:	8e e0       	ldi	r24, 0x0E	; 14
 1d2:	b0 df       	rcall	.-160    	; 0x134 <lcd_goto>
	if(select){
		lcd_puttext(PSTR("HZ"));
 1d4:	69 e4       	ldi	r22, 0x49	; 73
 1d6:	70 e0       	ldi	r23, 0x00	; 0
 1d8:	80 e0       	ldi	r24, 0x00	; 0
 1da:	92 df       	rcall	.-220    	; 0x100 <lcd_puttext>
 1dc:	4a e0       	ldi	r20, 0x0A	; 10
 1de:	b8 01       	movw	r22, r16
 1e0:	8d 85       	ldd	r24, Y+13	; 0x0d
 1e2:	9e 85       	ldd	r25, Y+14	; 0x0e
 1e4:	4b d2       	rcall	.+1174   	; 0x67c <__itoa_ncheck>
 1e6:	22 c0       	rjmp	.+68     	; 0x22c <refresh+0xd8>
	if(select){
		lcd_puttext(PSTR("FREQ:"));
		itoa(freq, str, 10);
	}
	else{
		lcd_puttext(PSTR("AMP:"));
 1e8:	6c e4       	ldi	r22, 0x4C	; 76
 1ea:	70 e0       	ldi	r23, 0x00	; 0
 1ec:	80 e0       	ldi	r24, 0x00	; 0
 1ee:	88 df       	rcall	.-240    	; 0x100 <lcd_puttext>
 1f0:	4a e0       	ldi	r20, 0x0A	; 10
 1f2:	8e 01       	movw	r16, r28
 1f4:	0f 5f       	subi	r16, 0xFF	; 255
 1f6:	1f 4f       	sbci	r17, 0xFF	; 255
 1f8:	b8 01       	movw	r22, r16
 1fa:	89 85       	ldd	r24, Y+9	; 0x09
 1fc:	9a 85       	ldd	r25, Y+10	; 0x0a
 1fe:	3e d2       	rcall	.+1148   	; 0x67c <__itoa_ncheck>
		itoa(amp, str, 10);
	}
	lcd_goto(5,0);
 200:	60 e0       	ldi	r22, 0x00	; 0
 202:	85 e0       	ldi	r24, 0x05	; 5
 204:	97 df       	rcall	.-210    	; 0x134 <lcd_goto>
	lcd_puttext(str);
 206:	c8 01       	movw	r24, r16
 208:	a0 e8       	ldi	r26, 0x80	; 128
 20a:	50 2e       	mov	r5, r16
 20c:	69 2e       	mov	r6, r25
 20e:	7a 2e       	mov	r7, r26
 210:	bc 01       	movw	r22, r24
 212:	8a 2f       	mov	r24, r26
 214:	75 df       	rcall	.-278    	; 0x100 <lcd_puttext>
	lcd_goto(14,0);
 216:	60 e0       	ldi	r22, 0x00	; 0
 218:	8e e0       	ldi	r24, 0x0E	; 14
 21a:	8c df       	rcall	.-232    	; 0x134 <lcd_goto>
	if(select){
		lcd_puttext(PSTR("HZ"));
		itoa(fjump, str, 10);
	}
	else{
		lcd_puttext(PSTR("A"));
 21c:	67 e4       	ldi	r22, 0x47	; 71
 21e:	70 e0       	ldi	r23, 0x00	; 0
 220:	80 e0       	ldi	r24, 0x00	; 0
 222:	6e df       	rcall	.-292    	; 0x100 <lcd_puttext>
 224:	4a e0       	ldi	r20, 0x0A	; 10
 226:	b8 01       	movw	r22, r16
 228:	c5 01       	movw	r24, r10
 22a:	28 d2       	rcall	.+1104   	; 0x67c <__itoa_ncheck>
		itoa(ajump, str, 10);
	}
	lcd_goto(0,1);
 22c:	61 e0       	ldi	r22, 0x01	; 1
 22e:	80 e0       	ldi	r24, 0x00	; 0
 230:	81 df       	rcall	.-254    	; 0x134 <lcd_goto>
	lcd_puttext(PSTR("JUMP"));
 232:	62 e4       	ldi	r22, 0x42	; 66
 234:	70 e0       	ldi	r23, 0x00	; 0
 236:	80 e0       	ldi	r24, 0x00	; 0
 238:	63 df       	rcall	.-314    	; 0x100 <lcd_puttext>
	lcd_goto(5,1);
 23a:	61 e0       	ldi	r22, 0x01	; 1
 23c:	85 e0       	ldi	r24, 0x05	; 5
 23e:	7a df       	rcall	.-268    	; 0x134 <lcd_goto>
	lcd_puttext(str);
 240:	65 2d       	mov	r22, r5
 242:	76 2d       	mov	r23, r6
 244:	87 2d       	mov	r24, r7
 246:	5c df       	rcall	.-328    	; 0x100 <lcd_puttext>
}
 248:	60 96       	adiw	r28, 0x10	; 16
 24a:	0f b6       	in	r0, 0x3f	; 63
 24c:	f8 94       	cli
 24e:	de bf       	out	0x3e, r29	; 62
 250:	0f be       	out	0x3f, r0	; 63
 252:	cd bf       	out	0x3d, r28	; 61
 254:	df 91       	pop	r29
 256:	cf 91       	pop	r28
 258:	1f 91       	pop	r17
 25a:	0f 91       	pop	r16
 25c:	ff 90       	pop	r15
 25e:	ef 90       	pop	r14
 260:	df 90       	pop	r13
 262:	cf 90       	pop	r12
 264:	bf 90       	pop	r11
 266:	af 90       	pop	r10
 268:	8f 90       	pop	r8
 26a:	7f 90       	pop	r7
 26c:	6f 90       	pop	r6
 26e:	5f 90       	pop	r5
 270:	4f 90       	pop	r4
 272:	08 95       	ret

00000274 <main>:

int main()
{
 274:	cf 93       	push	r28
 276:	df 93       	push	r29
 278:	00 d0       	rcall	.+0      	; 0x27a <main+0x6>
 27a:	00 d0       	rcall	.+0      	; 0x27c <main+0x8>
 27c:	1f 92       	push	r1
 27e:	cd b7       	in	r28, 0x3d	; 61
 280:	de b7       	in	r29, 0x3e	; 62
DDRB = 0x00;
 282:	17 ba       	out	0x17, r1	; 23
PORTB|=_BV(PB0) | _BV(PB7) | _BV(PB6);
 284:	88 b3       	in	r24, 0x18	; 24
 286:	81 6c       	ori	r24, 0xC1	; 193
 288:	88 bb       	out	0x18, r24	; 24

lcd_init();
 28a:	f7 de       	rcall	.-530    	; 0x7a <lcd_init>
 28c:	0f 2e       	mov	r0, r31
 28e:	f5 e0       	ldi	r31, 0x05	; 5
 290:	ff 2e       	mov	r15, r31
 292:	f0 2d       	mov	r31, r0
for(uint8_t i = 0; i < 5; i++){
	lcd_goto(1,0);
	lcd_puttext(PSTR("GIT GUD FAGGET"));
 294:	83 e3       	ldi	r24, 0x33	; 51
 296:	90 e0       	ldi	r25, 0x00	; 0
 298:	3c 01       	movw	r6, r24
 29a:	81 2c       	mov	r8, r1
	lcd_goto(2,1);
	lcd_puttext(PSTR("420 BLAZE IT"));
 29c:	86 e2       	ldi	r24, 0x26	; 38
 29e:	90 e0       	ldi	r25, 0x00	; 0
 2a0:	6c 01       	movw	r12, r24
 2a2:	e1 2c       	mov	r14, r1
DDRB = 0x00;
PORTB|=_BV(PB0) | _BV(PB7) | _BV(PB6);

lcd_init();
for(uint8_t i = 0; i < 5; i++){
	lcd_goto(1,0);
 2a4:	60 e0       	ldi	r22, 0x00	; 0
 2a6:	81 e0       	ldi	r24, 0x01	; 1
 2a8:	45 df       	rcall	.-374    	; 0x134 <lcd_goto>
	lcd_puttext(PSTR("GIT GUD FAGGET"));
 2aa:	88 2d       	mov	r24, r8
 2ac:	b3 01       	movw	r22, r6
 2ae:	28 df       	rcall	.-432    	; 0x100 <lcd_puttext>
	lcd_goto(2,1);
 2b0:	61 e0       	ldi	r22, 0x01	; 1
 2b2:	82 e0       	ldi	r24, 0x02	; 2
 2b4:	3f df       	rcall	.-386    	; 0x134 <lcd_goto>
	lcd_puttext(PSTR("420 BLAZE IT"));
 2b6:	8e 2d       	mov	r24, r14
 2b8:	b6 01       	movw	r22, r12
 2ba:	22 df       	rcall	.-444    	; 0x100 <lcd_puttext>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2bc:	87 ea       	ldi	r24, 0xA7	; 167
 2be:	91 e6       	ldi	r25, 0x61	; 97
 2c0:	01 97       	sbiw	r24, 0x01	; 1
 2c2:	f1 f7       	brne	.-4      	; 0x2c0 <main+0x4c>
 2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <main+0x52>
 2c6:	00 00       	nop
	_delay_ms(100);
	lcd_cls();
 2c8:	3f df       	rcall	.-386    	; 0x148 <lcd_cls>
 2ca:	e7 ea       	ldi	r30, 0xA7	; 167
 2cc:	f1 e6       	ldi	r31, 0x61	; 97
 2ce:	31 97       	sbiw	r30, 0x01	; 1
 2d0:	f1 f7       	brne	.-4      	; 0x2ce <main+0x5a>
 2d2:	00 c0       	rjmp	.+0      	; 0x2d4 <main+0x60>
 2d4:	00 00       	nop
 2d6:	fa 94       	dec	r15
{
DDRB = 0x00;
PORTB|=_BV(PB0) | _BV(PB7) | _BV(PB6);

lcd_init();
for(uint8_t i = 0; i < 5; i++){
 2d8:	29 f7       	brne	.-54     	; 0x2a4 <main+0x30>
uint32_t amp = 0, testf, testa, fjump = 1000, ajump = 10;
bool select = 0, tests = 0;
uint32_t freq;
for(uint8_t i = 0; i < 6; i++)
	freq = 0;
refresh(freq, amp, fjump, ajump, select);
 2da:	81 2c       	mov	r8, r1
 2dc:	0f 2e       	mov	r0, r31
 2de:	fa e0       	ldi	r31, 0x0A	; 10
 2e0:	af 2e       	mov	r10, r31
 2e2:	b1 2c       	mov	r11, r1
 2e4:	c1 2c       	mov	r12, r1
 2e6:	d1 2c       	mov	r13, r1
 2e8:	f0 2d       	mov	r31, r0
 2ea:	18 ee       	ldi	r17, 0xE8	; 232
 2ec:	e1 2e       	mov	r14, r17
 2ee:	13 e0       	ldi	r17, 0x03	; 3
 2f0:	f1 2e       	mov	r15, r17
 2f2:	00 e0       	ldi	r16, 0x00	; 0
 2f4:	10 e0       	ldi	r17, 0x00	; 0
 2f6:	20 e0       	ldi	r18, 0x00	; 0
 2f8:	30 e0       	ldi	r19, 0x00	; 0
 2fa:	a9 01       	movw	r20, r18
 2fc:	60 e0       	ldi	r22, 0x00	; 0
 2fe:	70 e0       	ldi	r23, 0x00	; 0
 300:	cb 01       	movw	r24, r22
 302:	28 df       	rcall	.-432    	; 0x154 <refresh>
 304:	81 2c       	mov	r8, r1
 306:	91 2c       	mov	r9, r1
 308:	54 01       	movw	r10, r8
	_delay_ms(100);
}


uint32_t amp = 0, testf, testa, fjump = 1000, ajump = 10;
bool select = 0, tests = 0;
 30a:	40 e0       	ldi	r20, 0x00	; 0
	lcd_cls();
	_delay_ms(100);
}


uint32_t amp = 0, testf, testa, fjump = 1000, ajump = 10;
 30c:	c1 2c       	mov	r12, r1
 30e:	d1 2c       	mov	r13, r1
 310:	76 01       	movw	r14, r12
		laststate&=(~_BV(PB7));
		laststate|=(state & _BV(PB7));
	}
	
	for(uint8_t c=0;c<sizeof(counters)/sizeof(counters[0]);c++)
	    if(counters[c])	counters[c]--;
 312:	0f 2e       	mov	r0, r31
 314:	f3 e6       	ldi	r31, 0x63	; 99
 316:	2f 2e       	mov	r2, r31
 318:	f0 e0       	ldi	r31, 0x00	; 0
 31a:	3f 2e       	mov	r3, r31
 31c:	f0 2d       	mov	r31, r0
 31e:	07 c0       	rjmp	.+14     	; 0x32e <main+0xba>
int main()
{
DDRB = 0x00;
PORTB|=_BV(PB0) | _BV(PB7) | _BV(PB6);

lcd_init();
 320:	89 80       	ldd	r8, Y+1	; 0x01
 322:	9a 80       	ldd	r9, Y+2	; 0x02
 324:	ab 80       	ldd	r10, Y+3	; 0x03
 326:	bc 80       	ldd	r11, Y+4	; 0x04
 328:	4d 81       	ldd	r20, Y+5	; 0x05
 32a:	73 01       	movw	r14, r6
 32c:	62 01       	movw	r12, r4
	testf = freq;
	testa = amp;
	tests = select;
	
	//////////PRZYCISK///////////
	if(!(PINB & _BV(PB6))){
 32e:	b6 99       	sbic	0x16, 6	; 22
 330:	0b c0       	rjmp	.+22     	; 0x348 <main+0xd4>
		select=!select;
 332:	f1 e0       	ldi	r31, 0x01	; 1
 334:	f4 27       	eor	r31, r20
 336:	fd 83       	std	Y+5, r31	; 0x05
 338:	87 ea       	ldi	r24, 0xA7	; 167
 33a:	91 e6       	ldi	r25, 0x61	; 97
 33c:	01 97       	sbiw	r24, 0x01	; 1
 33e:	f1 f7       	brne	.-4      	; 0x33c <main+0xc8>
 340:	00 c0       	rjmp	.+0      	; 0x342 <main+0xce>
 342:	00 00       	nop
 344:	8d 81       	ldd	r24, Y+5	; 0x05
 346:	02 c0       	rjmp	.+4      	; 0x34c <main+0xd8>
 348:	4d 83       	std	Y+5, r20	; 0x05
 34a:	84 2f       	mov	r24, r20
		_delay_ms(100);
	}
	while(!(PINB & _BV(PB6)));
 34c:	b6 9b       	sbis	0x16, 6	; 22
 34e:	fe cf       	rjmp	.-4      	; 0x34c <main+0xd8>
 350:	8d 83       	std	Y+5, r24	; 0x05
	
	////////////ENKODER//////////
	if(select){
 352:	88 23       	and	r24, r24
 354:	09 f4       	brne	.+2      	; 0x358 <main+0xe4>
 356:	5b c0       	rjmp	.+182    	; 0x40e <main+0x19a>
	static int8_t last;
	static uint8_t laststate;
	static uint8_t counters[2];	//Tablica zawieraj¹ca liczniki
	int8_t newpos, diff;
	
	uint8_t state=PINB;
 358:	86 b3       	in	r24, 0x16	; 22
	if(((state^laststate) & _BV(PB0)) && (counters[0]==0))
 35a:	90 91 65 00 	lds	r25, 0x0065
 35e:	29 2f       	mov	r18, r25
 360:	28 27       	eor	r18, r24
 362:	20 ff       	sbrs	r18, 0
 364:	0c c0       	rjmp	.+24     	; 0x37e <main+0x10a>
 366:	f1 01       	movw	r30, r2
 368:	20 81       	ld	r18, Z
 36a:	21 11       	cpse	r18, r1
 36c:	08 c0       	rjmp	.+16     	; 0x37e <main+0x10a>
	{
		counters[0]=200;
 36e:	08 ec       	ldi	r16, 0xC8	; 200
 370:	00 83       	st	Z, r16
		laststate&=(~_BV(PB0));
 372:	9e 7f       	andi	r25, 0xFE	; 254
		laststate|=(state & _BV(PB0));
 374:	28 2f       	mov	r18, r24
 376:	21 70       	andi	r18, 0x01	; 1
 378:	92 2b       	or	r25, r18
 37a:	90 93 65 00 	sts	0x0065, r25
	}

	if(((state^laststate) & _BV(PB7)) && (counters[1]==0))
 37e:	90 91 65 00 	lds	r25, 0x0065
 382:	29 2f       	mov	r18, r25
 384:	28 27       	eor	r18, r24
 386:	0c f0       	brlt	.+2      	; 0x38a <main+0x116>
 388:	dc c0       	rjmp	.+440    	; 0x542 <__stack+0xe3>
 38a:	e4 e6       	ldi	r30, 0x64	; 100
 38c:	f0 e0       	ldi	r31, 0x00	; 0
 38e:	20 81       	ld	r18, Z
 390:	21 11       	cpse	r18, r1
 392:	d7 c0       	rjmp	.+430    	; 0x542 <__stack+0xe3>
	{
		counters[1]=200;
 394:	08 ec       	ldi	r16, 0xC8	; 200
 396:	00 83       	st	Z, r16
		laststate&=(~_BV(PB7));
 398:	9f 77       	andi	r25, 0x7F	; 127
		laststate|=(state & _BV(PB7));
 39a:	80 78       	andi	r24, 0x80	; 128
 39c:	89 2b       	or	r24, r25
 39e:	80 93 65 00 	sts	0x0065, r24
 3a2:	cf c0       	rjmp	.+414    	; 0x542 <__stack+0xe3>
	}
	
	for(uint8_t c=0;c<sizeof(counters)/sizeof(counters[0]);c++)
	    if(counters[c])	counters[c]--;
 3a4:	81 50       	subi	r24, 0x01	; 1
 3a6:	e4 e6       	ldi	r30, 0x64	; 100
 3a8:	f0 e0       	ldi	r31, 0x00	; 0
 3aa:	80 83       	st	Z, r24

	newpos=0;
	if((PINB & _BV(PB0))==0) newpos=3;
 3ac:	b0 9b       	sbis	0x16, 0	; 22
 3ae:	02 c0       	rjmp	.+4      	; 0x3b4 <main+0x140>
	}
	
	for(uint8_t c=0;c<sizeof(counters)/sizeof(counters[0]);c++)
	    if(counters[c])	counters[c]--;

	newpos=0;
 3b0:	80 e0       	ldi	r24, 0x00	; 0
 3b2:	01 c0       	rjmp	.+2      	; 0x3b6 <main+0x142>
	if((PINB & _BV(PB0))==0) newpos=3;
 3b4:	83 e0       	ldi	r24, 0x03	; 3
	if((PINB & _BV(PB7))==0) newpos^=1;	// konwersja kodu Graya na binarny
 3b6:	b7 99       	sbic	0x16, 7	; 22
 3b8:	02 c0       	rjmp	.+4      	; 0x3be <main+0x14a>
 3ba:	f1 e0       	ldi	r31, 0x01	; 1
 3bc:	8f 27       	eor	r24, r31
	diff=last-newpos;
 3be:	90 91 62 00 	lds	r25, 0x0062
 3c2:	98 1b       	sub	r25, r24
	if(diff & 1)
 3c4:	90 ff       	sbrs	r25, 0
 3c6:	09 c0       	rjmp	.+18     	; 0x3da <main+0x166>
	{				// bit 0 = krok
		last=newpos;
 3c8:	80 93 62 00 	sts	0x0062, r24
		enc_delta+=(diff & 2)-1;	//bit 1 - kierunek
 3cc:	80 91 66 00 	lds	r24, 0x0066
 3d0:	81 50       	subi	r24, 0x01	; 1
 3d2:	92 70       	andi	r25, 0x02	; 2
 3d4:	98 0f       	add	r25, r24
 3d6:	90 93 66 00 	sts	0x0066, r25
}

int8_t Read2StepEncoder()
{
	ReadEncoder();
	int8_t val=enc_delta;
 3da:	a0 91 66 00 	lds	r26, 0x0066
	enc_delta=val & 1;
 3de:	8a 2f       	mov	r24, r26
 3e0:	81 70       	andi	r24, 0x01	; 1
 3e2:	80 93 66 00 	sts	0x0066, r24
	return val>>1;
 3e6:	a5 95       	asr	r26
		freq += (fjump * Read2StepEncoder());
 3e8:	bb 27       	eor	r27, r27
 3ea:	a7 fd       	sbrc	r26, 7
 3ec:	b0 95       	com	r27
 3ee:	28 ee       	ldi	r18, 0xE8	; 232
 3f0:	33 e0       	ldi	r19, 0x03	; 3
 3f2:	32 d1       	rcall	.+612    	; 0x658 <__usmulhisi3>
 3f4:	95 01       	movw	r18, r10
 3f6:	84 01       	movw	r16, r8
 3f8:	06 0f       	add	r16, r22
 3fa:	17 1f       	adc	r17, r23
 3fc:	28 1f       	adc	r18, r24
 3fe:	39 1f       	adc	r19, r25
 400:	09 83       	std	Y+1, r16	; 0x01
 402:	1a 83       	std	Y+2, r17	; 0x02
 404:	2b 83       	std	Y+3, r18	; 0x03
 406:	3c 83       	std	Y+4, r19	; 0x04
 408:	26 01       	movw	r4, r12
 40a:	37 01       	movw	r6, r14
 40c:	68 c0       	rjmp	.+208    	; 0x4de <__stack+0x7f>
	static int8_t last;
	static uint8_t laststate;
	static uint8_t counters[2];	//Tablica zawieraj¹ca liczniki
	int8_t newpos, diff;
	
	uint8_t state=PINB;
 40e:	86 b3       	in	r24, 0x16	; 22
	if(((state^laststate) & _BV(PB0)) && (counters[0]==0))
 410:	90 91 65 00 	lds	r25, 0x0065
 414:	29 2f       	mov	r18, r25
 416:	28 27       	eor	r18, r24
 418:	20 ff       	sbrs	r18, 0
 41a:	0c c0       	rjmp	.+24     	; 0x434 <main+0x1c0>
 41c:	f1 01       	movw	r30, r2
 41e:	20 81       	ld	r18, Z
 420:	21 11       	cpse	r18, r1
 422:	08 c0       	rjmp	.+16     	; 0x434 <main+0x1c0>
	{
		counters[0]=200;
 424:	08 ec       	ldi	r16, 0xC8	; 200
 426:	00 83       	st	Z, r16
		laststate&=(~_BV(PB0));
 428:	9e 7f       	andi	r25, 0xFE	; 254
		laststate|=(state & _BV(PB0));
 42a:	28 2f       	mov	r18, r24
 42c:	21 70       	andi	r18, 0x01	; 1
 42e:	92 2b       	or	r25, r18
 430:	90 93 65 00 	sts	0x0065, r25
	}

	if(((state^laststate) & _BV(PB7)) && (counters[1]==0))
 434:	90 91 65 00 	lds	r25, 0x0065
 438:	29 2f       	mov	r18, r25
 43a:	28 27       	eor	r18, r24
 43c:	0c f0       	brlt	.+2      	; 0x440 <main+0x1cc>
 43e:	8d c0       	rjmp	.+282    	; 0x55a <__stack+0xfb>
 440:	e4 e6       	ldi	r30, 0x64	; 100
 442:	f0 e0       	ldi	r31, 0x00	; 0
 444:	20 81       	ld	r18, Z
 446:	21 11       	cpse	r18, r1
 448:	88 c0       	rjmp	.+272    	; 0x55a <__stack+0xfb>
	{
		counters[1]=200;
 44a:	08 ec       	ldi	r16, 0xC8	; 200
 44c:	00 83       	st	Z, r16
		laststate&=(~_BV(PB7));
 44e:	9f 77       	andi	r25, 0x7F	; 127
		laststate|=(state & _BV(PB7));
 450:	80 78       	andi	r24, 0x80	; 128
 452:	89 2b       	or	r24, r25
 454:	80 93 65 00 	sts	0x0065, r24
 458:	80 c0       	rjmp	.+256    	; 0x55a <__stack+0xfb>
	}
	
	for(uint8_t c=0;c<sizeof(counters)/sizeof(counters[0]);c++)
	    if(counters[c])	counters[c]--;
 45a:	81 50       	subi	r24, 0x01	; 1
 45c:	e4 e6       	ldi	r30, 0x64	; 100
 45e:	f0 e0       	ldi	r31, 0x00	; 0
 460:	80 83       	st	Z, r24

	newpos=0;
	if((PINB & _BV(PB0))==0) newpos=3;
 462:	b0 9b       	sbis	0x16, 0	; 22
 464:	02 c0       	rjmp	.+4      	; 0x46a <__stack+0xb>
	}
	
	for(uint8_t c=0;c<sizeof(counters)/sizeof(counters[0]);c++)
	    if(counters[c])	counters[c]--;

	newpos=0;
 466:	80 e0       	ldi	r24, 0x00	; 0
 468:	01 c0       	rjmp	.+2      	; 0x46c <__stack+0xd>
	if((PINB & _BV(PB0))==0) newpos=3;
 46a:	83 e0       	ldi	r24, 0x03	; 3
	if((PINB & _BV(PB7))==0) newpos^=1;	// konwersja kodu Graya na binarny
 46c:	b7 99       	sbic	0x16, 7	; 22
 46e:	02 c0       	rjmp	.+4      	; 0x474 <__stack+0x15>
 470:	f1 e0       	ldi	r31, 0x01	; 1
 472:	8f 27       	eor	r24, r31
	diff=last-newpos;
 474:	90 91 62 00 	lds	r25, 0x0062
 478:	98 1b       	sub	r25, r24
	if(diff & 1)
 47a:	90 ff       	sbrs	r25, 0
 47c:	09 c0       	rjmp	.+18     	; 0x490 <__stack+0x31>
	{				// bit 0 = krok
		last=newpos;
 47e:	80 93 62 00 	sts	0x0062, r24
		enc_delta+=(diff & 2)-1;	//bit 1 - kierunek
 482:	80 91 66 00 	lds	r24, 0x0066
 486:	81 50       	subi	r24, 0x01	; 1
 488:	92 70       	andi	r25, 0x02	; 2
 48a:	98 0f       	add	r25, r24
 48c:	90 93 66 00 	sts	0x0066, r25
}

int8_t Read2StepEncoder()
{
	ReadEncoder();
	int8_t val=enc_delta;
 490:	90 91 66 00 	lds	r25, 0x0066
	enc_delta=val & 1;
 494:	89 2f       	mov	r24, r25
 496:	81 70       	andi	r24, 0x01	; 1
 498:	80 93 66 00 	sts	0x0066, r24
	return val>>1;
 49c:	49 2e       	mov	r4, r25
 49e:	45 94       	asr	r4
	}else{
		amp += (ajump * Read2StepEncoder());
 4a0:	55 24       	eor	r5, r5
 4a2:	47 fc       	sbrc	r4, 7
 4a4:	50 94       	com	r5
 4a6:	65 2c       	mov	r6, r5
 4a8:	75 2c       	mov	r7, r5
 4aa:	44 0c       	add	r4, r4
 4ac:	55 1c       	adc	r5, r5
 4ae:	66 1c       	adc	r6, r6
 4b0:	77 1c       	adc	r7, r7
 4b2:	d3 01       	movw	r26, r6
 4b4:	c2 01       	movw	r24, r4
 4b6:	88 0f       	add	r24, r24
 4b8:	99 1f       	adc	r25, r25
 4ba:	aa 1f       	adc	r26, r26
 4bc:	bb 1f       	adc	r27, r27
 4be:	88 0f       	add	r24, r24
 4c0:	99 1f       	adc	r25, r25
 4c2:	aa 1f       	adc	r26, r26
 4c4:	bb 1f       	adc	r27, r27
 4c6:	48 0e       	add	r4, r24
 4c8:	59 1e       	adc	r5, r25
 4ca:	6a 1e       	adc	r6, r26
 4cc:	7b 1e       	adc	r7, r27
 4ce:	4c 0c       	add	r4, r12
 4d0:	5d 1c       	adc	r5, r13
 4d2:	6e 1c       	adc	r6, r14
 4d4:	7f 1c       	adc	r7, r15
 4d6:	89 82       	std	Y+1, r8	; 0x01
 4d8:	9a 82       	std	Y+2, r9	; 0x02
 4da:	ab 82       	std	Y+3, r10	; 0x03
 4dc:	bc 82       	std	Y+4, r11	; 0x04
	}
	
	///////////REFRESH///////////
	if((freq!=testf) | (amp!=testa) | (select!=tests)){
 4de:	91 e0       	ldi	r25, 0x01	; 1
 4e0:	09 81       	ldd	r16, Y+1	; 0x01
 4e2:	1a 81       	ldd	r17, Y+2	; 0x02
 4e4:	2b 81       	ldd	r18, Y+3	; 0x03
 4e6:	3c 81       	ldd	r19, Y+4	; 0x04
 4e8:	80 16       	cp	r8, r16
 4ea:	91 06       	cpc	r9, r17
 4ec:	a2 06       	cpc	r10, r18
 4ee:	b3 06       	cpc	r11, r19
 4f0:	09 f4       	brne	.+2      	; 0x4f4 <__stack+0x95>
 4f2:	90 e0       	ldi	r25, 0x00	; 0
 4f4:	81 e0       	ldi	r24, 0x01	; 1
 4f6:	c4 14       	cp	r12, r4
 4f8:	d5 04       	cpc	r13, r5
 4fa:	e6 04       	cpc	r14, r6
 4fc:	f7 04       	cpc	r15, r7
 4fe:	09 f4       	brne	.+2      	; 0x502 <__stack+0xa3>
 500:	80 e0       	ldi	r24, 0x00	; 0
 502:	89 2b       	or	r24, r25
 504:	41 f4       	brne	.+16     	; 0x516 <__stack+0xb7>
 506:	81 e0       	ldi	r24, 0x01	; 1
 508:	1d 81       	ldd	r17, Y+5	; 0x05
 50a:	41 13       	cpse	r20, r17
 50c:	01 c0       	rjmp	.+2      	; 0x510 <__stack+0xb1>
 50e:	80 e0       	ldi	r24, 0x00	; 0
 510:	88 23       	and	r24, r24
 512:	09 f4       	brne	.+2      	; 0x516 <__stack+0xb7>
 514:	05 cf       	rjmp	.-502    	; 0x320 <main+0xac>
		refresh(freq, amp, fjump, ajump, select);
 516:	8d 80       	ldd	r8, Y+5	; 0x05
 518:	0f 2e       	mov	r0, r31
 51a:	fa e0       	ldi	r31, 0x0A	; 10
 51c:	af 2e       	mov	r10, r31
 51e:	b1 2c       	mov	r11, r1
 520:	c1 2c       	mov	r12, r1
 522:	d1 2c       	mov	r13, r1
 524:	f0 2d       	mov	r31, r0
 526:	18 ee       	ldi	r17, 0xE8	; 232
 528:	e1 2e       	mov	r14, r17
 52a:	13 e0       	ldi	r17, 0x03	; 3
 52c:	f1 2e       	mov	r15, r17
 52e:	00 e0       	ldi	r16, 0x00	; 0
 530:	10 e0       	ldi	r17, 0x00	; 0
 532:	a3 01       	movw	r20, r6
 534:	92 01       	movw	r18, r4
 536:	69 81       	ldd	r22, Y+1	; 0x01
 538:	7a 81       	ldd	r23, Y+2	; 0x02
 53a:	8b 81       	ldd	r24, Y+3	; 0x03
 53c:	9c 81       	ldd	r25, Y+4	; 0x04
 53e:	0a de       	rcall	.-1004   	; 0x154 <refresh>
 540:	ef ce       	rjmp	.-546    	; 0x320 <main+0xac>
		laststate&=(~_BV(PB7));
		laststate|=(state & _BV(PB7));
	}
	
	for(uint8_t c=0;c<sizeof(counters)/sizeof(counters[0]);c++)
	    if(counters[c])	counters[c]--;
 542:	f1 01       	movw	r30, r2
 544:	80 81       	ld	r24, Z
 546:	88 23       	and	r24, r24
 548:	11 f0       	breq	.+4      	; 0x54e <__stack+0xef>
 54a:	81 50       	subi	r24, 0x01	; 1
 54c:	80 83       	st	Z, r24
 54e:	e4 e6       	ldi	r30, 0x64	; 100
 550:	f0 e0       	ldi	r31, 0x00	; 0
 552:	80 81       	ld	r24, Z
 554:	81 11       	cpse	r24, r1
 556:	26 cf       	rjmp	.-436    	; 0x3a4 <main+0x130>
 558:	29 cf       	rjmp	.-430    	; 0x3ac <main+0x138>
 55a:	f1 01       	movw	r30, r2
 55c:	80 81       	ld	r24, Z
 55e:	88 23       	and	r24, r24
 560:	11 f0       	breq	.+4      	; 0x566 <__stack+0x107>
 562:	81 50       	subi	r24, 0x01	; 1
 564:	80 83       	st	Z, r24
 566:	e4 e6       	ldi	r30, 0x64	; 100
 568:	f0 e0       	ldi	r31, 0x00	; 0
 56a:	80 81       	ld	r24, Z
 56c:	81 11       	cpse	r24, r1
 56e:	75 cf       	rjmp	.-278    	; 0x45a <main+0x1e6>
 570:	78 cf       	rjmp	.-272    	; 0x462 <__stack+0x3>

00000572 <hd44780_outnibble>:
 * Send one nibble out to the LCD controller.
 */
static void
hd44780_outnibble(uint8_t n, uint8_t rs)
{
  CLR(PORT, HD44780_RW);
 572:	93 98       	cbi	0x12, 3	; 18
  if (rs)
 574:	66 23       	and	r22, r22
 576:	11 f0       	breq	.+4      	; 0x57c <hd44780_outnibble+0xa>
    SET(PORT, HD44780_RS);
 578:	94 9a       	sbi	0x12, 4	; 18
 57a:	01 c0       	rjmp	.+2      	; 0x57e <hd44780_outnibble+0xc>
  else
    CLR(PORT, HD44780_RS);
 57c:	94 98       	cbi	0x12, 4	; 18
  ASSIGN(PORT, HD44780_D4, n);
 57e:	95 b3       	in	r25, 0x15	; 21
 580:	90 7f       	andi	r25, 0xF0	; 240
 582:	89 2b       	or	r24, r25
 584:	85 bb       	out	0x15, r24	; 21
static inline uint8_t
hd44780_pulse_e(bool readback)
{
  uint8_t x;

  SET(PORT, HD44780_E);
 586:	92 9a       	sbi	0x12, 2	; 18
#endif
  if (readback)
    x = READ(PIN, HD44780_D4);
  else
    x = 0;
  CLR(PORT, HD44780_E);
 588:	92 98       	cbi	0x12, 2	; 18
 58a:	08 95       	ret

0000058c <hd44780_innibble>:
static uint8_t
hd44780_innibble(uint8_t rs)
{
  uint8_t x;

  SET(PORT, HD44780_RW);
 58c:	93 9a       	sbi	0x12, 3	; 18
  ASSIGN(DDR, HD44780_D4, 0x00);
 58e:	94 b3       	in	r25, 0x14	; 20
 590:	90 7f       	andi	r25, 0xF0	; 240
 592:	94 bb       	out	0x14, r25	; 20
  if (rs)
 594:	88 23       	and	r24, r24
 596:	11 f0       	breq	.+4      	; 0x59c <hd44780_innibble+0x10>
    SET(PORT, HD44780_RS);
 598:	94 9a       	sbi	0x12, 4	; 18
 59a:	01 c0       	rjmp	.+2      	; 0x59e <hd44780_innibble+0x12>
  else
    CLR(PORT, HD44780_RS);
 59c:	94 98       	cbi	0x12, 4	; 18
static inline uint8_t
hd44780_pulse_e(bool readback)
{
  uint8_t x;

  SET(PORT, HD44780_E);
 59e:	92 9a       	sbi	0x12, 2	; 18
   * back from the input pin is sampled close to the beginning of a
   * CPU clock cycle, while the previous edge on the output pin is
   * generated towards the end of a CPU clock cycle.
   */
  if (readback)
    __asm__ volatile("nop");
 5a0:	00 00       	nop
  __asm__ volatile("nop");
#    endif /* F_CPU > 2000000UL */
#  endif /* F_CPU > 1000000UL */
#endif
  if (readback)
    x = READ(PIN, HD44780_D4);
 5a2:	83 b3       	in	r24, 0x13	; 19
  else
    x = 0;
  CLR(PORT, HD44780_E);
 5a4:	92 98       	cbi	0x12, 2	; 18
  if (rs)
    SET(PORT, HD44780_RS);
  else
    CLR(PORT, HD44780_RS);
  x = hd44780_pulse_e(true);
  ASSIGN(DDR, HD44780_D4, 0x0F);
 5a6:	94 b3       	in	r25, 0x14	; 20
 5a8:	9f 60       	ori	r25, 0x0F	; 15
 5aa:	94 bb       	out	0x14, r25	; 20
  CLR(PORT, HD44780_RW);
 5ac:	93 98       	cbi	0x12, 3	; 18

  return x;
}
 5ae:	8f 70       	andi	r24, 0x0F	; 15
 5b0:	08 95       	ret

000005b2 <hd44780_outbyte>:
 * Send one byte to the LCD controller.  As we are in 4-bit mode, we
 * have to send two nibbles.
 */
void
hd44780_outbyte(uint8_t b, uint8_t rs)
{
 5b2:	cf 93       	push	r28
 5b4:	df 93       	push	r29
 5b6:	c8 2f       	mov	r28, r24
 5b8:	d6 2f       	mov	r29, r22
  hd44780_outnibble(b >> 4, rs);
 5ba:	82 95       	swap	r24
 5bc:	8f 70       	andi	r24, 0x0F	; 15
 5be:	d9 df       	rcall	.-78     	; 0x572 <hd44780_outnibble>
  hd44780_outnibble(b & 0xf, rs);
 5c0:	6d 2f       	mov	r22, r29
 5c2:	8c 2f       	mov	r24, r28
 5c4:	8f 70       	andi	r24, 0x0F	; 15
 5c6:	d5 df       	rcall	.-86     	; 0x572 <hd44780_outnibble>
}
 5c8:	df 91       	pop	r29
 5ca:	cf 91       	pop	r28
 5cc:	08 95       	ret

000005ce <hd44780_inbyte>:
/*
 * Read one byte (i.e. two nibbles) from the LCD controller.
 */
uint8_t
hd44780_inbyte(uint8_t rs)
{
 5ce:	cf 93       	push	r28
 5d0:	df 93       	push	r29
 5d2:	c8 2f       	mov	r28, r24
  uint8_t x;

  x = hd44780_innibble(rs) << 4;
 5d4:	db df       	rcall	.-74     	; 0x58c <hd44780_innibble>
 5d6:	d8 2f       	mov	r29, r24
 5d8:	d2 95       	swap	r29
 5da:	d0 7f       	andi	r29, 0xF0	; 240
  x |= hd44780_innibble(rs);
 5dc:	8c 2f       	mov	r24, r28
 5de:	d6 df       	rcall	.-84     	; 0x58c <hd44780_innibble>

  return x;
}
 5e0:	8d 2b       	or	r24, r29
 5e2:	df 91       	pop	r29
 5e4:	cf 91       	pop	r28
 5e6:	08 95       	ret

000005e8 <hd44780_wait_ready>:
 */
void
hd44780_wait_ready(bool longwait)
{
#if USE_BUSY_BIT
  while (hd44780_incmd() & HD44780_BUSYFLAG) ;
 5e8:	80 e0       	ldi	r24, 0x00	; 0
 5ea:	f1 df       	rcall	.-30     	; 0x5ce <hd44780_inbyte>
 5ec:	88 23       	and	r24, r24
 5ee:	e4 f3       	brlt	.-8      	; 0x5e8 <hd44780_wait_ready>
  if (longwait)
    _delay_ms(1.52);
  else
    _delay_us(37);
#endif
}
 5f0:	08 95       	ret

000005f2 <hd44780_init>:
 * the busy flag cannot be probed initially.
 */
void
hd44780_init(void)
{
  SET(DDR, HD44780_RS);
 5f2:	8c 9a       	sbi	0x11, 4	; 17
  SET(DDR, HD44780_RW);
 5f4:	8b 9a       	sbi	0x11, 3	; 17
  SET(DDR, HD44780_E);
 5f6:	8a 9a       	sbi	0x11, 2	; 17
  ASSIGN(DDR, HD44780_D4, 0x0F);
 5f8:	84 b3       	in	r24, 0x14	; 20
 5fa:	8f 60       	ori	r24, 0x0F	; 15
 5fc:	84 bb       	out	0x14, r24	; 20
 5fe:	85 ea       	ldi	r24, 0xA5	; 165
 600:	9e e0       	ldi	r25, 0x0E	; 14
 602:	01 97       	sbiw	r24, 0x01	; 1
 604:	f1 f7       	brne	.-4      	; 0x602 <hd44780_init+0x10>
 606:	00 c0       	rjmp	.+0      	; 0x608 <hd44780_init+0x16>
 608:	00 00       	nop

  _delay_ms(15);		/* 40 ms needed for Vcc = 2.7 V */
  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
 60a:	60 e0       	ldi	r22, 0x00	; 0
 60c:	83 e0       	ldi	r24, 0x03	; 3
 60e:	b1 df       	rcall	.-158    	; 0x572 <hd44780_outnibble>
 610:	80 e0       	ldi	r24, 0x00	; 0
 612:	94 e0       	ldi	r25, 0x04	; 4
 614:	01 97       	sbiw	r24, 0x01	; 1
 616:	f1 f7       	brne	.-4      	; 0x614 <hd44780_init+0x22>
 618:	00 c0       	rjmp	.+0      	; 0x61a <hd44780_init+0x28>
 61a:	00 00       	nop
  _delay_ms(4.1);
  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
 61c:	60 e0       	ldi	r22, 0x00	; 0
 61e:	83 e0       	ldi	r24, 0x03	; 3
 620:	a8 df       	rcall	.-176    	; 0x572 <hd44780_outnibble>
 622:	91 e2       	ldi	r25, 0x21	; 33
 624:	9a 95       	dec	r25
 626:	f1 f7       	brne	.-4      	; 0x624 <hd44780_init+0x32>
 628:	00 00       	nop
  _delay_ms(0.1);
  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
 62a:	60 e0       	ldi	r22, 0x00	; 0
 62c:	83 e0       	ldi	r24, 0x03	; 3
 62e:	a1 df       	rcall	.-190    	; 0x572 <hd44780_outnibble>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 630:	8c e0       	ldi	r24, 0x0C	; 12
 632:	8a 95       	dec	r24
 634:	f1 f7       	brne	.-4      	; 0x632 <hd44780_init+0x40>
 636:	00 00       	nop
  _delay_us(37);

  hd44780_outnibble(HD44780_FNSET(0, 1, 0) >> 4, 0);
 638:	60 e0       	ldi	r22, 0x00	; 0
 63a:	82 e0       	ldi	r24, 0x02	; 2
 63c:	9a df       	rcall	.-204    	; 0x572 <hd44780_outnibble>
  hd44780_wait_ready(false);
 63e:	80 e0       	ldi	r24, 0x00	; 0
 640:	d3 df       	rcall	.-90     	; 0x5e8 <hd44780_wait_ready>
  hd44780_outcmd(HD44780_FNSET(0, 1, 0));
 642:	60 e0       	ldi	r22, 0x00	; 0
 644:	88 e2       	ldi	r24, 0x28	; 40
 646:	b5 df       	rcall	.-150    	; 0x5b2 <hd44780_outbyte>
  hd44780_wait_ready(false);
 648:	80 e0       	ldi	r24, 0x00	; 0
 64a:	ce df       	rcall	.-100    	; 0x5e8 <hd44780_wait_ready>
  hd44780_outcmd(HD44780_DISPCTL(0, 0, 0));
 64c:	60 e0       	ldi	r22, 0x00	; 0
 64e:	88 e0       	ldi	r24, 0x08	; 8
 650:	b0 df       	rcall	.-160    	; 0x5b2 <hd44780_outbyte>
  hd44780_wait_ready(false);
 652:	80 e0       	ldi	r24, 0x00	; 0
 654:	c9 df       	rcall	.-110    	; 0x5e8 <hd44780_wait_ready>
 656:	08 95       	ret

00000658 <__usmulhisi3>:
 658:	05 d0       	rcall	.+10     	; 0x664 <__umulhisi3>

0000065a <__usmulhisi3_tail>:
 65a:	b7 ff       	sbrs	r27, 7
 65c:	08 95       	ret
 65e:	82 1b       	sub	r24, r18
 660:	93 0b       	sbc	r25, r19
 662:	08 95       	ret

00000664 <__umulhisi3>:
 664:	a2 9f       	mul	r26, r18
 666:	b0 01       	movw	r22, r0
 668:	b3 9f       	mul	r27, r19
 66a:	c0 01       	movw	r24, r0
 66c:	a3 9f       	mul	r26, r19
 66e:	01 d0       	rcall	.+2      	; 0x672 <__umulhisi3+0xe>
 670:	b2 9f       	mul	r27, r18
 672:	70 0d       	add	r23, r0
 674:	81 1d       	adc	r24, r1
 676:	11 24       	eor	r1, r1
 678:	91 1d       	adc	r25, r1
 67a:	08 95       	ret

0000067c <__itoa_ncheck>:
 67c:	bb 27       	eor	r27, r27
 67e:	4a 30       	cpi	r20, 0x0A	; 10
 680:	31 f4       	brne	.+12     	; 0x68e <__itoa_ncheck+0x12>
 682:	99 23       	and	r25, r25
 684:	22 f4       	brpl	.+8      	; 0x68e <__itoa_ncheck+0x12>
 686:	bd e2       	ldi	r27, 0x2D	; 45
 688:	90 95       	com	r25
 68a:	81 95       	neg	r24
 68c:	9f 4f       	sbci	r25, 0xFF	; 255
 68e:	01 c0       	rjmp	.+2      	; 0x692 <__utoa_common>

00000690 <__utoa_ncheck>:
 690:	bb 27       	eor	r27, r27

00000692 <__utoa_common>:
 692:	fb 01       	movw	r30, r22
 694:	55 27       	eor	r21, r21
 696:	aa 27       	eor	r26, r26
 698:	88 0f       	add	r24, r24
 69a:	99 1f       	adc	r25, r25
 69c:	aa 1f       	adc	r26, r26
 69e:	a4 17       	cp	r26, r20
 6a0:	10 f0       	brcs	.+4      	; 0x6a6 <__utoa_common+0x14>
 6a2:	a4 1b       	sub	r26, r20
 6a4:	83 95       	inc	r24
 6a6:	50 51       	subi	r21, 0x10	; 16
 6a8:	b9 f7       	brne	.-18     	; 0x698 <__utoa_common+0x6>
 6aa:	a0 5d       	subi	r26, 0xD0	; 208
 6ac:	aa 33       	cpi	r26, 0x3A	; 58
 6ae:	08 f0       	brcs	.+2      	; 0x6b2 <__utoa_common+0x20>
 6b0:	a9 5d       	subi	r26, 0xD9	; 217
 6b2:	a1 93       	st	Z+, r26
 6b4:	00 97       	sbiw	r24, 0x00	; 0
 6b6:	79 f7       	brne	.-34     	; 0x696 <__utoa_common+0x4>
 6b8:	b1 11       	cpse	r27, r1
 6ba:	b1 93       	st	Z+, r27
 6bc:	11 92       	st	Z+, r1
 6be:	cb 01       	movw	r24, r22
 6c0:	00 c0       	rjmp	.+0      	; 0x6c2 <strrev>

000006c2 <strrev>:
 6c2:	dc 01       	movw	r26, r24
 6c4:	fc 01       	movw	r30, r24
 6c6:	67 2f       	mov	r22, r23
 6c8:	71 91       	ld	r23, Z+
 6ca:	77 23       	and	r23, r23
 6cc:	e1 f7       	brne	.-8      	; 0x6c6 <strrev+0x4>
 6ce:	32 97       	sbiw	r30, 0x02	; 2
 6d0:	04 c0       	rjmp	.+8      	; 0x6da <strrev+0x18>
 6d2:	7c 91       	ld	r23, X
 6d4:	6d 93       	st	X+, r22
 6d6:	70 83       	st	Z, r23
 6d8:	62 91       	ld	r22, -Z
 6da:	ae 17       	cp	r26, r30
 6dc:	bf 07       	cpc	r27, r31
 6de:	c8 f3       	brcs	.-14     	; 0x6d2 <strrev+0x10>
 6e0:	08 95       	ret

000006e2 <_exit>:
 6e2:	f8 94       	cli

000006e4 <__stop_program>:
 6e4:	ff cf       	rjmp	.-2      	; 0x6e4 <__stop_program>
